<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Go - Tag - vpereira01</title><link>https://vpereira01.com/tags/go/</link><description>Go - Tag - vpereira01</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 13 May 2022 15:15:11 +0100</lastBuildDate><atom:link href="https://vpereira01.com/tags/go/" rel="self" type="application/rss+xml"/><item><title>Go big.Int add one performance curiosity</title><link>https://vpereira01.com/posts/go-bigint-perf/</link><pubDate>Fri, 13 May 2022 15:15:11 +0100</pubDate><author>xxxx</author><guid>https://vpereira01.com/posts/go-bigint-perf/</guid><description><![CDATA[<p>Trying to solve a coding exercise I noticed that doing <code>z.Add(z, one)</code> is kind of slow so I implemented my own increment method :)</p>
<p>Practicing Go by solving the CodeWars <a href="https://www.codewars.com//kata/54cb771c9b30e8b5250011d4" target="_blank" rel="noopener noreffer ">exercise</a> &ldquo;Faberg√© Easter Eggs crush test&rdquo;, I was able to find a simple, and slow solution, by performing many many additions. This simple solution was enough to meet the test requirements but something bugged me from my CPU profilings, <code>z.Add(z, one)</code> was taking cumulative more than one second. In comparison, adding two big numbers was taking cumulative more than five seconds.</p>]]></description></item></channel></rss>